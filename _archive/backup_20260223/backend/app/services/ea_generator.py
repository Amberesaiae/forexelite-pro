"""EA Generator service for creating MQL5 expert advisors from templates."""

import logging
from datetime import datetime, timezone
from typing import Optional

from jinja2 import Environment, BaseLoader
from supabase import create_client

from app.core.config import settings

logger = logging.getLogger(__name__)


# MQL5 template for a simple moving average crossover EA
MA_CROSSOVER_TEMPLATE = '''//+------------------------------------------------------------------+
//| {{ name }} - Generated by ForexElite Pro                          |
//+------------------------------------------------------------------+
#property version "{{ version }}"
#property strict

// Input parameters
input double LotSize = {{ lot_size }};
input int FastMA_Period = {{ fast_ma_period }};
input int SlowMA_Period = {{ slow_ma_period }};
input int MA_Shift = 0;
input ENUM_MA_METHOD MA_Method = MODE_SMA;
input ENUM_APPLIED_PRICE Applied_Price = PRICE_CLOSE;

// Global variables
int FastMA_Handle;
int SlowMA_Handle;
double FastMA_Buffer[];
double SlowMA_Buffer[];
datetime LastBarTime;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Create MA indicators
   FastMA_Handle = iMA(_Symbol, _Period, FastMA_Period, MA_Shift, MA_Method, Applied_Price);
   SlowMA_Handle = iMA(_Symbol, _Period, SlowMA_Period, MA_Shift, MA_Method, Applied_Price);
   
   if(FastMA_Handle == INVALID_HANDLE || SlowMA_Handle == INVALID_HANDLE)
   {
      Print("Failed to create MA indicators");
      return INIT_FAILED;
   }
   
   // Initialize buffers
   ArraySetAsSeries(FastMA_Buffer, true);
   ArraySetAsSeries(SlowMA_Buffer, true);
   
   LastBarTime = 0;
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   if(FastMA_Handle != INVALID_HANDLE)
      IndicatorRelease(FastMA_Handle);
   if(SlowMA_Handle != INVALID_HANDLE)
      IndicatorRelease(SlowMA_Handle);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Check for new bar
   if(LastBarTime == Time[0])
      return;
   LastBarTime = Time[0];
   
   // Copy indicator values
   CopyBuffer(FastMA_Handle, 0, 0, 3, FastMA_Buffer);
   CopyBuffer(SlowMA_Handle, 0, 0, 3, SlowMA_Buffer);
   
   // Get current prices
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   
   // Check for crossover signals
   if(FastMA_Buffer[1] < SlowMA_Buffer[1] && FastMA_Buffer[0] > SlowMA_Buffer[0])
   {
      // Golden cross - Buy signal
      CloseExistingPositions();
      OpenPosition(ORDER_TYPE_BUY, LotSize, ask);
   }
   else if(FastMA_Buffer[1] > SlowMA_Buffer[1] && FastMA_Buffer[0] < SlowMA_Buffer[0])
   {
      // Death cross - Sell signal
      CloseExistingPositions();
      OpenPosition(ORDER_TYPE_SELL, LotSize, bid);
   }
}

//+------------------------------------------------------------------+
//| Open a trading position                                          |
//+------------------------------------------------------------------+
void OpenPosition(ENUM_ORDER_TYPE type, double volume, double price)
{
   MqlTradeRequest request = {};
   MqlTradeResult result = {};
   
   request.action = TRADE_ACTION_DEAL;
   request.symbol = _Symbol;
   request.volume = volume;
   request.type = type;
   request.price = price;
   request.deviation = 10;
   request.magic = 123456;
   
   if(!OrderSend(request, result))
   {
      Print("OrderSend failed: ", result.retcode);
   }
}

//+------------------------------------------------------------------+
//| Close all existing positions                                     |
//+------------------------------------------------------------------+
void CloseExistingPositions()
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(PositionGetSymbol(i) == _Symbol && PositionGetInteger(POSITION_MAGIC) == 123456)
      {
         MqlTradeRequest request = {};
         MqlTradeResult result = {};
         
         request.action = TRADE_ACTION_DEAL;
         request.symbol = _Symbol;
         request.volume = PositionGetDouble(POSITION_VOLUME);
         request.type = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? ORDER_TYPE_SELL : ORDER_TYPE_BUY;
         request.price = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? SymbolInfoDouble(_Symbol, SYMBOL_BID) : SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         request.deviation = 10;
         request.position = PositionGetInteger(POSITION_TICKET);
         
         if(!OrderSend(request, result))
         {
            Print("OrderSend failed: ", result.retcode);
         }
      }
   }
}
//+------------------------------------------------------------------+
'''


class EAGenerator:
    """Service for generating MQL5 expert advisors from templates."""
    
    def __init__(self):
        """Initialize EA generator."""
        self.jinja_env = Environment(loader=BaseLoader())
        self.templates = {
            "ma_crossover": MA_CROSSOVER_TEMPLATE
        }
    
    def generate_from_template(
        self,
        template_name: str,
        project_name: str,
        config: dict
    ) -> str:
        """
        Generate MQL5 source code from a template.
        
        Args:
            template_name: Name of the template to use
            project_name: Name of the EA project
            config: Configuration parameters for the template
            
        Returns:
            Generated MQL5 source code
        """
        if template_name not in self.templates:
            raise ValueError(f"Unknown template: {template_name}")
        
        template = self.jinja_env.from_string(self.templates[template_name])
        
        # Default values
        defaults = {
            "name": project_name,
            "version": "1.0",
            "lot_size": 0.1,
            "fast_ma_period": 10,
            "slow_ma_period": 20
        }
        
        # Merge defaults with config
        params = {**defaults, **config}
        
        return template.render(**params)
    
    async def save_generated_ea(
        self,
        user_id: str,
        project_id: str,
        version_number: int,
        template_name: str,
        config: dict
    ) -> dict:
        """
        Generate and save an EA version.
        
        Args:
            user_id: User ID
            project_id: EA project ID
            version_number: Version number
            template_name: Template to use
            config: Template configuration
            
        Returns:
            Created version record
        """
        # Generate source code
        client = create_client(
            settings.SUPABASE_URL,
            settings.SUPABASE_SERVICE_ROLE_KEY
        )
        
        # Get project name
        project_result = client.table("ea_projects").select("name").eq("id", project_id).execute()
        if not project_result.data:
            raise ValueError(f"Project not found: {project_id}")
        
        project_name = project_result.data[0]["name"]
        
        # Generate source code
        source_code = self.generate_from_template(template_name, project_name, config)
        
        # Create version
        now = datetime.now(timezone.utc)
        result = client.table("ea_versions").insert({
            "ea_project_id": project_id,
            "version_number": version_number,
            "source_code": {
                "template": template_name,
                "code": source_code,
                "config": config
            },
            "config": config,
            "status": "draft",
            "created_at": now.isoformat(),
            "updated_at": now.isoformat()
        }).execute()
        
        return result.data[0]
    
    def list_templates(self) -> list[dict]:
        """
        List available EA templates.
        
        Returns:
            List of template information
        """
        return [
            {
                "id": "ma_crossover",
                "name": "Moving Average Crossover",
                "description": "Simple MA crossover strategy",
                "parameters": ["lot_size", "fast_ma_period", "slow_ma_period"]
            }
        ]